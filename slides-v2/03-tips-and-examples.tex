\section{GNU Make tips}

\defverbatim[colored]\makeVar{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
# Immediate evaluation
VAR1 := some-value

# Lazy evaluation
VAR2 = some-other-value
    \end{lstlisting}
}

\defverbatim[colored]\makeAppendVar{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
# OK - becomes "still-some-value"
VAR1 := still-$(VAR1)
# OK - becomes "still-some-value another-value" (note the space)
VAR1 += another-value

# OK - becomes "another-value yet-another-value"
VAR2 += yet-another-value
# NOT OK!!
VAR2 = $(VAR2) dont
    \end{lstlisting}
}

\subsection{Variable attribution}
\begin{frame}{\secname: \small\subsecname\normalsize}
    Attributing a value to a variable is as simples as doing:

    \makeVar

    And variables may be modified by using:

    \makeAppendVar

\end{frame}

\defverbatim[colored]\makeObjsFromSrc{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
SRC := main.c foo.c
# Assigns 'main.o foo.o' to OBJS
OBJS := $(SRC:%.c=%.o)
    \end{lstlisting}
}

\defverbatim[colored]\makeDir{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
# Resolves to the implicit '%.o: %.c' rule
obj/%.o: src/%.c | obj/%.mkdir

# From a previous example
%.app: $(OBJS) | %.mkdir

# $(@D) retrieves the directory of
# the current target
%.mkdir:
	mkdir -p $(@D)
	touch $@
    \end{lstlisting}
}

\subsection{Variable substitution (mkdir)}
\begin{frame}{\secname: \small\subsecname\normalsize}
    Variable substitution may happen when accessing a variable:

    \makeObjsFromSrc

    Using the \textbf{automatic variable} \texttt{\$(@D)} it's possible to automatically generate the directory for a given target:

    \makeDir

\end{frame}

\defverbatim[colored]\makeCustomTarget{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
ifneq (, $(findstring debug, $(MAKECMDGOALS)) )
    # Building a %_debug target
    CFLAGS := $(CFLAGS) -O0 -g -DDEBUG
else
    # Building a release target
    CFLAGS := $(CFLAGS) -O2
endif

ifneq (, $(findstring linux, $(MAKECMDGOALS)) )
    \end{lstlisting}
}

\subsection{Customizing targets}
\begin{frame}{\secname: \small\subsecname\normalsize}

    Using string comparison/manipulation function, one can customize a target's flags: \\~\\

    \makeCustomTarget

\end{frame}

\defverbatim[colored]\makeCross{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
linux32: bin/linux32/my-program.app
win32: bin/win32/my-program.app

OBJS := $(SRC:%.c=obj/$(MAKECMDGOALS)/%.o)

%.app: $(OBJS) | %.app.mkdir
	$(CC) # ...

obj/$(MAKECMDGOALS)/%.o: %.c | obj/$(MAKECMDGOALS)/%.mkdir
	$(CC) -c # ...

%.mkdir:
	mkdir -p $(@D)
    \end{lstlisting}
}

\subsection{Simultaneous builds}
\begin{frame}{\secname: \small\subsecname\normalsize}
    It's possible to maintain multiple build configurations based on the target (which avoids having to \texttt{make clean} between builds). \\~\\

    \makeCross

\end{frame}

\defverbatim[colored]\makeAutoSrc{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
# To find every .c file in src:
#   FILES := $(call rwildcard, src/, *.c)
# To find all the .c and .h files in src:
#   FILES := $(call rwildcard, src/, *.c *.h)
rwildcard=$(foreach d,$(wildcard $1*), \
    $(call rwildcard,$d/,$2) \
    $(filter $(subst *,%,$2),$d))

# For example
SRC := $(call rwildcard, src, *.c)
OBJS := $(SRC:%.c=%.o)
    \end{lstlisting}
}

\subsection{Automatic source list}
\begin{frame}{\secname: \small\subsecname\normalsize}

    This was taken from Stack Overflow, and uses functions \texttt{foreach}, \texttt{call}, \texttt{filter} and \texttt{subst} to list files under a directory: \\~\\

    \makeAutoSrc
\end{frame}

\defverbatim[colored]\makeHeaders{
    \begin{lstlisting}[basicstyle=\tiny, language=make]
# Include every rule from a depency (properly
# tracks header dependency)
-include $(OBJS:%.o=%.d)

obj/%.o: src/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# Create the dependency files from
# their source
obj/%.d: %.c
	gcc $(CFLAGS) -MM -MG \
	    -MT "$@ $(@:%.d=%.o)" $< > $@
    \end{lstlisting}
}

\subsection{Properly tracking header files}
\begin{frame}{\secname: \small\subsecname\normalsize}
	The following targets/rules can be used to properly keep track of included headers, minimizing the amount of \texttt{make clean} required: \\~\\

	\makeHeaders

    \begin{alertblock}{Attention!}
        The headers must only include as few other headers as it needs.
    \end{alertblock}
\end{frame}
